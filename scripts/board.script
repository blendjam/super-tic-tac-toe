local utils = require("utils.utils")
local lines = {}
local function set_line_color(color)
    for i = 1, 4 do
        lines[i] = { root = "line" .. i, sprite = "line" .. i .. "#sprite" }
        go.set(lines[i].sprite, "tint", color)
    end
end
function init(self)
    set_line_color(vmath.vector4(0, 0, 0, 1))
    self.board = {
        { "", "", "" },
        { "", "", "" },
        { "", "", "" },
        { "", "", "" }
    }
    go.set("#board_area", "tint.w", 0)
    self.board_scale = go.get_scale().x
    self.board_size = go.get("#board_area", "size") * self.board_scale
    self.winning_line = { p1 = { i = 0, j = 0 }, p2 = { i = 0, j = 0 } }
    self.winner = utils.WinnerType.NONE
    -- AudioManager
end

local function get_position_from_index(self, index)
    local cell_size = self.board_size.x / (3 * self.board_scale)
    return vmath.vector3((index.j - 2) * cell_size, (index.i - 2) * cell_size, 0)
end

local function is_touching_board(self, touch_position)
    local board_position = go.get_position()
    local board_size = self.board_size.x / 2
    return touch_position.x >= board_position.x - board_size and touch_position.x <= board_position.x + board_size
        and touch_position.y >= board_position.y - board_size and touch_position.y <= board_position.y + board_size
end

local function check_winner(self)
    for i = 1, 3 do
        if self.board[i][1] ~= "" and self.board[i][1] == self.board[i][2] and self.board[i][1] == self.board[i][3] then
            self.winner = utils.PlayerType[self.board[i][1]]
            self.winning_line.p1 = { i = i, j = 1 }
            self.winning_line.p2 = { i = i, j = 3 }
            return true
        end
    end

    for j = 1, 3 do
        if self.board[1][j] ~= "" and self.board[1][j] == self.board[2][j] and self.board[1][j] == self.board[3][j] then
            self.winner = utils.PlayerType[self.board[1][j]]
            self.winning_line.p1 = { i = 1, j = j }
            self.winning_line.p2 = { i = 3, j = j }
            return true
        end
    end

    if self.board[1][1] ~= "" and self.board[1][1] == self.board[2][2] and self.board[1][1] == self.board[3][3] then
        self.winner = utils.PlayerType[self.board[1][1]]
        self.winning_line.p1 = { i = 1, j = 1 }
        self.winning_line.p2 = { i = 3, j = 3 }
        return true
    end

    if self.board[1][3] ~= "" and self.board[1][3] == self.board[2][2] and self.board[1][3] == self.board[3][1] then
        self.winner = utils.PlayerType[self.board[1][3]]
        self.winning_line.p1 = { i = 1, j = 3 }
        self.winning_line.p2 = { i = 3, j = 1 }
        return true
    end

    return false
end

local function is_board_full(self)
    for i = 1, 3 do
        for j = 1, 3 do
            if self.board[i][j] == "" then
                return false
            end
        end
    end
    return true
end

local function on_board_touch(self, touch_position, turn, play_state)
    if play_state ~= utils.PlayState.PLAY then return end
    touch_position = utils.screen_to_world(touch_position)
    if not is_touching_board(self, touch_position) then return end

    --Get board position
    local i = 0
    local j = 0

    local offset = 100 * self.board_scale
    if touch_position.x > go.get_position().x + offset then
        j = 1
    elseif touch_position.x < go.get_position().x - offset then
        j = -1
    end
    if touch_position.y > go.get_position().y + offset then
        i = 1
    elseif touch_position.y < go.get_position().y - offset then
        i = -1
    end

    if self.board[i + 2][j + 2] == "" then
        local x_pos = go.get_position().x + j * offset * 2
        local y_pos = go.get_position().y + i * offset * 2
        if turn == 1 then
            self.board[i + 2][j + 2] = utils.PlayerType.CIRCLE
            msg.post("shape_spawner", "spawn_shape",
                { shape = "circle", position = vmath.vector3(x_pos, y_pos, 0) })
        else
            self.board[i + 2][j + 2] = utils.PlayerType.CROSS
            msg.post("shape_spawner", "spawn_shape",
                { shape = "cross", position = vmath.vector3(x_pos, y_pos, 0) })
        end

        if check_winner(self) then
            self.winning_line.p1 = get_position_from_index(self, self.winning_line.p1)
            self.winning_line.p2 = get_position_from_index(self, self.winning_line.p2)
            set_line_color(vmath.vector4(0.7, 0.7, 0.7, 1))
            msg.post("game:/game_controller", "on_board_complete",
                { winner = self.winner, winning_line = self.winning_line, last_index = { 2 - i, j + 2 } })
        elseif is_board_full(self) then
            set_line_color(vmath.vector4(0.7, 0.7, 0.7, 1))
            msg.post("game:/game_controller", "on_board_complete",
                { winner = utils.WinnerType.TIE, last_index = { 2 - i, j + 2 } })
        else
            msg.post("game:/game_controller", "change_turn", { last_index = { 2 - i, j + 2 } })
        end
    end
end

local function set_selected(self, selected)
    if self.winner ~= utils.WinnerType.NONE then
        set_line_color(vmath.vector4(0.5, 0.5, 0.5, 1))
        return
    end
    if selected then
        AudioManager:play_oneshot("zoom_in")
        set_line_color(vmath.vector4(1))
    else
        set_line_color(vmath.vector4(0, 0, 0, 1))
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("on_touch") then
        on_board_touch(self, message.position, message.turn, message.play_state)
    end
    if message_id == hash("set_selected") then
        set_selected(self, message.selected)
    end
end
