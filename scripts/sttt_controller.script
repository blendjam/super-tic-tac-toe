local utils = require("utils.utils")
local PlayerType = utils.PlayerType
local PlayState = utils.PlayState
local game_state = require("modules.game_state")
game_state:reset_state()

local NUM_PLAYERS = 2

local background_color = {
    vmath.vector4(0.4470588, 0.6164325, 1.0, 1),
    vmath.vector4(1, 0.4470588, 0.4470588, 1),
}

local function change_turn(self, last_index)
    self.turn = (self.turn % NUM_PLAYERS) + 1
    go.set(self.background, "tint", background_color[self.turn])
    msg.post("game:/board/board", "select_board", { index = last_index })
    go.set(self.background, "tint", background_color[self.turn])
    msg.post("game:/game_gui", "change_turn", { player_type = self.player_type, turn = self.turn })
    if self.player_type == "computer" and self.turn == 2 and self.play_state ~= PlayState.END then
        timer.delay(1.5, false, function()
            msg.post("game:/bot", "get_move")
        end)
    end
end

function init(self)
    self.turn = 1
    self.play_state = PlayState.FULLVIEW
    self.background = "game:/background#sprite"
    go.set(self.background, "tint", background_color[self.turn])
    msg.post("game:/game_gui", "show_zoom_button")
    msg.post("game:/board/board", "select_all")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("on_touch") then
        if self.player_type == "computer" then
            if self.turn == 1 then
                msg.post("game:/board/board", "on_touch",
                    {
                        position = message.position,
                        turn = self.turn,
                        play_state = self.play_state
                    })
            end
        else
            msg.post("game:/board/board", "on_touch",
                {
                    position = message.position,
                    turn = self.turn,
                    play_state = self.play_state
                })
        end
    end

    if message_id == hash("bot_play") then
        msg.post("game:/board/board", "play_action",
            { index1 = message.index1, index2 = message.index2, turn = self.turn, play_state = self.play_state })
    end

    if message_id == hash("change_turn") then
        change_turn(self, message.last_index)
    end
    if message_id == hash("zoom_in") then
        self.play_state = PlayState.ZOOMIN
        msg.post("game:/camera_controller", "zoom_in", { target_position = message.target_position })
    end
    if message_id == hash("reset_zoom") then
        self.play_state = PlayState.ZOOMOUT
        msg.post("game:/camera_controller", "reset_zoom")
    end
    if message_id == hash("zoom_in_complete") then
        self.play_state = PlayState.PLAY
        msg.post("game:/game_gui", "enable_zoom_button")
    end
    if message_id == hash("zoom_out_complete") then
        self.play_state = PlayState.FULLVIEW
        msg.post("game:/game_gui", "disable_zoom_button")
    end

    if message_id == hash("on_shape_spawn") then
        msg.post("game:/board/board", "on_shape_spawn", message)
    end

    if message_id == hash("on_game_end") then
        if message.winner ~= utils.WinnerType.NONE then
            self.play_state = PlayState.END
            msg.post("game:/game_gui", "on_game_end", { winner = message.winner })
        end
    end

    if message_id == hash("on_board_complete") then
        local position = go.get_position(sender)
        msg.post("game:/board/board", "board_complete", { winner = message.winner, position = position })
        if message.winner ~= utils.WinnerType.TIE then
            msg.post("shape_spawner", "spawn_shape", { shape = message.winner, position = position })
        end
        timer.delay(0.1, false, function()
            change_turn(self, message.last_index)
        end)
    end

    if message_id == hash("level_loaded") then
        self.player_type = message.player_type
    end
end
