local utils = require("utils.utils")
local lines = {}
local line_offset = 100

local function is_touching_board(self, touch_position)
	local board_position = go.get_position()
	local board_size = self.board_size.x / 2
	return touch_position.x >= board_position.x - board_size and touch_position.x <= board_position.x + board_size
		and touch_position.y >= board_position.y - board_size and touch_position.y <= board_position.y + board_size
end

function init(self)
	for i = 1, 4 do
		lines[i] = { root = "/line" .. i, sprite = msg.url(nil, "line" .. i, "sprite") }
		go.set(lines[i].sprite, "tint", vmath.vector4(0, 0, 0, 1))
	end
	go.set("#board_area", "tint.w", 0)
	self.board_size = go.get("#board_area", "size")
	self.board_scale = go.get_scale().x
	self.winner = utils.WinnerType.NONE
	self.winning_line = { p1 = { i = 0, j = 0 }, p2 = { i = 0, j = 0 } }
	self.line_width = 30
	self.boards = {}
	for i = 1, 3 do
		self.boards[i] = {}
		for j = 1, 3 do
			self.boards[i][j] = {
				url = "board" .. i .. j .. "/board",
				selected = false,
				completed = false,
				winner = utils.WinnerType.NONE
			}
		end
	end
end

local function get_board_index(self, world_position)
	local line_offset = 100             -- or use your actual value
	local board_origin = go.get_position() -- center of board

	-- Calculate column (j)
	local j
	if world_position.x < board_origin.x - line_offset then
		j = 1
	elseif world_position.x < board_origin.x + line_offset then
		j = 2
	else
		j = 3
	end

	local i
	if world_position.y > board_origin.y + line_offset then
		i = 1
	elseif world_position.y > board_origin.y - line_offset then
		i = 2
	else
		i = 3
	end

	return i, j
end

local function get_position_from_index(self, index)
	local cell_size = self.board_size.x / (3 * self.board_scale)
	return vmath.vector3((index.j - 2) * cell_size, (2 - index.i) * cell_size, 0)
end

local function check_winner(self)
	for i = 1, 3 do
		if self.boards[i][1].winner ~= utils.WinnerType.NONE and self.boards[i][1].winner == self.boards[i][2].winner and self.boards[i][1].winner == self.boards[i][3].winner then
			self.winner = self.boards[i][1].winner
			self.winning_line.p1 = { i = i, j = 1 }
			self.winning_line.p2 = { i = i, j = 3 }
			return true
		end
	end

	for j = 1, 3 do
		if self.boards[1][j].winner ~= utils.WinnerType.NONE and self.boards[1][j].winner == self.boards[2][j].winner and self.boards[1][j].winner == self.boards[3][j].winner then
			self.winner = self.boards[1][j].winner
			self.winning_line.p1 = { i = 1, j = j }
			self.winning_line.p2 = { i = 3, j = j }
			return true
		end
	end

	if self.boards[1][1].winner ~= utils.WinnerType.NONE and self.boards[1][1].winner == self.boards[2][2].winner and self.boards[1][1].winner == self.boards[3][3].winner then
		self.winner = self.boards[1][1].winner
		self.winning_line.p1 = { i = 1, j = 1 }
		self.winning_line.p2 = { i = 3, j = 3 }
		return true
	end

	if self.boards[1][3].winner ~= utils.WinnerType.NONE and self.boards[1][3].winner == self.boards[2][2].winner and self.boards[1][3].winner == self.boards[3][1].winner then
		self.winner = self.boards[1][3].winner
		self.winning_line.p1 = { i = 1, j = 3 }
		self.winning_line.p2 = { i = 3, j = 1 }
		return true
	end

	return false
end

local function get_board_position(world_position)
	local x = 0
	local y = 0

	if world_position.x > go.get_position().x + line_offset then
		x = 1
	elseif world_position.x < go.get_position().x - line_offset then
		x = -1
	end
	if world_position.y > go.get_position().y + line_offset then
		y = 1
	elseif world_position.y < go.get_position().y - line_offset then
		y = -1
	end
	return vmath.vector3(x * line_offset * 2, y * line_offset * 2, 0)
end


local function check_board_full(self)
	local is_full = true
	for i = 1, #self.boards do
		if self.boards[i].completed then
			is_full = false
			return
		end
	end
	if is_full and self.winner == utils.PlayerType.NONE then
		self.winner = utils.WinnerType.TIE
	end
end

local function is_touching_child_board(self, touch_position)
	local child_pos = get_board_position(utils.screen_to_world(touch_position))
	local board_position = go.get_position()
	local board_size = self.board_size.x / 2
	return touch_position.x >= board_position.x - board_size and touch_position.x <= board_position.x + board_size
		and touch_position.y >= board_position.y - board_size and touch_position.y <= board_position.y + board_size
end

local function on_board_touch(self, touch_position, turn, play_state)
	local world_pos = utils.screen_to_world(touch_position)
	if play_state == utils.PlayState.PLAY then
		msg.post("game:/game_controller", "reset_zoom")
	end
	if not is_touching_board(self, world_pos) then return end
	if play_state == utils.PlayState.PLAY then
		local i, j = get_board_index(self, world_pos)
		msg.post(self.boards[i][j].url, "on_touch", { position = touch_position, turn = turn, play_state = play_state })
	elseif play_state == utils.PlayState.FULLVIEW then
		local i, j = get_board_index(self, world_pos)
		if self.boards[i][j].selected and not self.boards[i][j].completed then
			msg.post("game:/game_controller", "zoom_in", { target_position = get_board_position(world_pos) })
		end
	end
end

local function draw_final_line(self)
	local final_line    = "/board/line"
	local p1            = get_position_from_index(self, self.winning_line.p1)
	local p2            = get_position_from_index(self, self.winning_line.p2)
	local line_rotation = math.atan2(p1.y - p2.y, p1.x - p2.x)
	local median_point  = vmath.vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, 3)
	go.set(final_line, "rotation", vmath.quat_rotation_z(line_rotation))
	go.set(final_line, "position", median_point)
	go.animate(final_line, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1), gui.EASING_OUTBACK, 0.3)
	AudioManager:play_oneshot("pen_stroke")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("on_touch") then
		on_board_touch(self, message.position, message.turn, message.play_state)
	end

	if message_id == hash("board_complete") then
		local i, j = get_board_index(self, message.position)
		self.boards[i][j].winner = message.winner
		self.boards[i][j].completed = true
		if check_winner(self) then
			msg.post("game:/game_controller", "on_game_end", { winner = self.winner })
			draw_final_line(self)
		elseif check_board_full(self) then
			msg.post("game:/game_controller", "on_game_end", { winner = utils.WinnerType.TIE })
		end
	end

	if message_id == hash("select_all") then
		for i = 1, 3 do
			for j = 1, 3 do
				if not self.boards[i][j].completed then
					msg.post(self.boards[i][j].url, "set_selected", { selected = true })
					self.boards[i][j].selected = true
				end
			end
		end
	end

	if message_id == hash("select_board") then
		if message.index == nil then return end
		for i = 1, 3 do
			for j = 1, 3 do
				msg.post(self.boards[i][j].url, "set_selected", { selected = false })
				self.boards[i][j].selected = false
			end
		end
		local board = self.boards[message.index[1]][message.index[2]]
		board.selected = true
		msg.post(board.url, "set_selected", { selected = true })
		if board.completed then
			msg.post(".", "select_all")
		end
	end
end

--     [Export] string crossLocation;
--     [Export] string circleLocation;
--     PackedScene crossPrefab;
--     public string[,] board;
--     public Node2D[,] boardObjects;
--     public bool isSelected;
--     public PlayerTurn winner;
--     public Vector2[] winningLine;
--     Line2D lineRenderer;
--     TTTController gameController;
--     Area2D area2D;
--     CollisionShape2D collisionShape2D;
--     Node2D winnerPrefab = null;
--     AudioManager audioManager;


--     // Start is called before the first frame update
--     public override void _Ready()
--     {
--         isSelected = false;
--         winner = PlayerTurn.NONE;
--         gameController = GetTree().Root.GetNode<TTTController>("SuperMode/GameController");
--         audioManager = GetNode<AudioManager>("/root/AudioManager");
--         boardObjects = new Node2D[3, 3];
--         winningLine = new Vector2[2] { Vector2.Zero, Vector2.Zero };
--         board = new string[3, 3]{
--             {null, null, null},
--             {null, null, null},
--             {null, null, null}
--         };

--         circlePrefab = GD.Load<PackedScene>(circleLocation);
--         crossPrefab = GD.Load<PackedScene>(crossLocation);
--         lineRenderer = GetNode<Line2D>("Line2D");
--         collisionShape2D = GetNode<CollisionShape2D>("Area2D/CollisionShape2D");
--         ChangeColor();
--     }

--     public override void _Input(InputEvent @event)
--     {
--         ChangeColor();
--         if (@event is InputEventScreenTouch screenTouch && screenTouch.Pressed && isSelected)
--         {
--             OnBoardTouch(screenTouch.Position);
--             if (winner != PlayerTurn.NONE && winnerPrefab == null)
--             {
--                 for (int i = 0; i < 2; i++)
--                     lineRenderer.SetPointPosition(i, winningLine[i]);

--                 if (winner == PlayerTurn.CROSS)
--                     winnerPrefab = crossPrefab.Instantiate() as Node2D;
--                 else if (winner == PlayerTurn.CIRCLE)
--                     winnerPrefab = circlePrefab.Instantiate() as Node2D;
--                 if (winnerPrefab == null) return;
--                 AddChild(winnerPrefab);
--                 winnerPrefab.ZIndex = 10;
--                 winnerPrefab.Position = Position;
--                 winnerPrefab.GetNode<AnimationPlayer>("AnimationPlayer").SpeedScale = 0.2f;
--                 winnerPrefab.Scale *= 5f;
--                 audioManager.PlaySFX(audioManager.boardWin);
--             }
--         }
--     }

--     // Update is called once per frame
--     public override void _Process(double delta)
--     {
--         if (isSelected && gameController.playState == PlayState.FULLVIEW)
--             collisionShape2D.Disabled = false;
--         else
--             collisionShape2D.Disabled = true;

--         if (winner != PlayerTurn.NONE)
--             collisionShape2D.Disabled = true;

--     }

--     void OnBoardTouch(Vector2 touchPosition)
--     {
--         if (gameController.playState == PlayState.PLAY)
--         {
--             //Touch Position in world space
--             // Vector2 touchPosition = GetViewport().CanvasTransform.AffineInverse() * screenTouch.Position;
--             Vector2 worldPosition = GetLocalMousePosition();
--             if (!IsTouchingBoard(worldPosition)) return;

--             //Get board position
--             int i = 0;
--             int j = 0;

--             float offset = 100f;
--             if (worldPosition.Y < Position.Y - offset)
--                 i = -1;
--             else if (worldPosition.Y > Position.Y + offset)
--                 i = 1;
--             if (worldPosition.X < Position.X - offset)
--                 j = -1;
--             else if (worldPosition.X > Position.X + offset)
--                 j = 1;
--             if (board[i + 1, j + 1] == null)
--             {
--                 float xPos = Position.X + j * offset * 2;
--                 float yPos = Position.Y + i * offset * 2;
--                 if (gameController.playerTurn == PlayerTurn.CIRCLE)
--                 {
--                     board[i + 1, j + 1] = "o";
--                     boardObjects[i + 1, j + 1] = circlePrefab.Instantiate() as Node2D;
--                     boardObjects[i + 1, j + 1].Position = new Vector2(xPos, yPos);
--                     AddChild(boardObjects[i + 1, j + 1]);
--                     audioManager.PlaySFX(audioManager.circleDraw);
--                 }
--                 else
--                 {
--                     board[i + 1, j + 1] = "x";
--                     boardObjects[i + 1, j + 1] = crossPrefab.Instantiate() as Node2D;
--                     boardObjects[i + 1, j + 1].Position = new Vector2(xPos, yPos);
--                     AddChild(boardObjects[i + 1, j + 1]);
--                     audioManager.PlaySFX(audioManager.crossDraw);
--                 }
--                 string s = "";
--                 for (int k = 0; k < 3; k++)
--                 {
--                     for (int l = 0; l < 3; l++)
--                     {
--                         s += board[k, l] + " ";
--                     }
--                     s = "\n";
--                 }
--                 CheckWinner();
--                 gameController.ChangeTurns(new int[] { i + 1, j + 1 });
--                 gameController.ResetCamera();
--             }
--         }
--     }

--     bool IsTouchingBoard(Vector2 touchPosition)
--     {
--         ColorRect colorRect = GetNode<ColorRect>("ColorRect");
--         if (colorRect.GetRect().HasPoint(touchPosition))
--         {
--             return true;
--         }
--         return false;
--     }

--     void ChangeColor()
--     {
--         foreach (Sprite2D child in GetNode("BoardLines").GetChildren())
--         {
--             if (isSelected)
--                 child.Modulate = Colors.White;
--             // transform.GetChild(i).GetComponent<SpriteRenderer>().color = Color.white;
--             else if (winner != PlayerTurn.NONE)
--                 child.Modulate = Colors.Gray;
--             else
--                 child.Modulate = Colors.Black;
--         }
--     }
--     void CheckWinner()
--     {
--         //Check if corss or circle won the match
--         //Check rows
--         for (int i = 0; i < 3; i++)
--         {
--             if (board[i, 0] == board[i, 1] && board[i, 1] == board[i, 2] && board[i, 0] != null)
--             {
--                 if (board[i, 0] == "x")
--                     winner = PlayerTurn.CROSS;

--                 else if (board[i, 0] == "o")
--                     winner = PlayerTurn.CIRCLE;

--                 winningLine[0] = boardObjects[i, 0].Position;
--                 winningLine[1] = boardObjects[i, 2].Position;
--             }
--         }
--         //Check columns
--         for (int i = 0; i < 3; i++)
--         {
--             if (board[0, i] == board[1, i] && board[1, i] == board[2, i] && board[0, i] != null)
--             {
--                 if (board[0, i] == "x")
--                     winner = PlayerTurn.CROSS;
--                 else if (board[0, i] == "o")
--                     winner = PlayerTurn.CIRCLE;
--                 winningLine[0] = boardObjects[0, i].Position;
--                 winningLine[1] = boardObjects[2, i].Position;
--             }
--         }
--         //Check diagonals
--         if (board[0, 0] == board[1, 1] && board[1, 1] == board[2, 2] && board[0, 0] != null)
--         {
--             if (board[0, 0] == "x")
--                 winner = PlayerTurn.CROSS;
--             else if (board[0, 0] == "o")
--                 winner = PlayerTurn.CIRCLE;
--             winningLine[0] = boardObjects[0, 0].Position;
--             winningLine[1] = boardObjects[2, 2].Position;
--         }
--         //Check diagonals
--         if (board[0, 2] == board[1, 1] && board[1, 1] == board[2, 0] && board[0, 2] != null)
--         {
--             if (board[0, 2] == "x")
--                 winner = PlayerTurn.CROSS;
--             else if (board[0, 2] == "o")
--                 winner = PlayerTurn.CIRCLE;
--             winningLine[0] = boardObjects[0, 2].Position;
--             winningLine[1] = boardObjects[2, 0].Position;
--         }
--         //Check if the board is full
--         bool isFull = true;
--         foreach (string s in board)
--         {
--             if (s == null)
--             {
--                 isFull = false;
--                 break;
--             }
--         }
--         if (isFull && winner == PlayerTurn.NONE)
--         {
--             winner = PlayerTurn.TIE;
--         }
--     }



-- }
