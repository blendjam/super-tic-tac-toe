local utils = require("utils.utils")
local druid = require("druid.druid")

local draw_color = vmath.vector4(0.5, 0.5, 0.5, 0.8)

local background_color = {
	[utils.WinnerType.CROSS] = vmath.vector4(1, 0.4470588, 0.4470588, 0.8),
	[utils.WinnerType.CIRCLE] = vmath.vector4(0.4470588, 0.6164325, 1.0, 0.8),
}

local game_mode = hash("normal_mode")

function init(self)
	msg.post(".", "acquire_input_focus")
	self.druid = druid.new(self)
	self.home_button = self.druid:new_button("home_button", function()
		LevelController:load_level(LevelController.Levels.main_menu, nil, true)
	end)
	self.end_game = gui.get_node("end_game")
	self.end_game_overlay = gui.get_node("overlay")
	self.your_turn = gui.get_node("your_turn")
	self.turn_text = gui.get_node("turn_text")
	gui.set_enabled(self.end_game, false)
end

function on_input(self, action_id, action)
	if self.druid:on_input(action_id, action) then
		return true
	end
	if action_id == hash("touch") and action.pressed and gui.is_enabled(self.end_game) then
		return true
	end
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)

	if message_id == hash("show_zoom_button") then
		self.zoom_button = self.druid:new_button("zoom_out", function()
			msg.post("game:/game_controller", "reset_zoom")
		end)
		gui.set_enabled(self.zoom_button.node, true)
	end

	if message_id == hash("change_turn") then
		if message.player_type == "computer" then
			if message.turn == 1 then
				gui.set_text(self.turn_text, "Your Turn")
			else
				gui.set_text(self.turn_text, "Bot Turn")
			end
		else
			if message.turn == 1 then
				gui.set_text(self.turn_text, "Circle Turn")
			else
				gui.set_text(self.turn_text, "Cross Turn")
			end
		end
		gui.animate(self.your_turn, "scale", vmath.vector3(1), gui.EASING_OUTBACK, 0.3, 0, function()
			gui.animate(self.your_turn, "scale", vmath.vector3(0), gui.EASING_INBACK, 0.3, 0.5)
		end)
	end

	if message_id == hash("disable_zoom_button") then
		self.zoom_button:set_enabled(false)
		gui.play_flipbook(self.zoom_button.node, "Full Screen Disabled")
	end

	if message_id == hash("enable_zoom_button") then
		self.zoom_button:set_enabled(true)
		gui.play_flipbook(self.zoom_button.node, "Zoom_Out")
	end

	if message_id == hash("on_game_end") then
		self.replay_button = self.druid:new_button("replay_button", function()
			LevelController:load_level(LevelController.Levels.main_menu, nil, true)
		end)
		gui.set_enabled(self.end_game, true)
		gui.set(self.end_game, "color.w", 0)
		gui.animate(self.end_game, "color.w", 1, gui.EASING_LINEAR, 0.3)

		local win_text = gui.get_node("win_text")
		gui.set(win_text, "scale", vmath.vector3(0, 0, 1))
		gui.animate(win_text, "scale", vmath.vector3(2.3), gui.EASING_OUTBACK, 0.3)

		gui.set(self.replay_button.node, "scale", vmath.vector3(0, 0, 1))
		gui.animate(self.replay_button.node, "scale", vmath.vector3(1), gui.EASING_OUTBACK, 0.3, 0.2)

		if message.winner == utils.WinnerType.TIE then
			gui.set(self.end_game_overlay, "color", draw_color)
			gui.set_text(win_text, "It's a Draw!")
			AudioManager:play_oneshot("tie")
		else
			gui.set(self.end_game_overlay, "color", background_color[message.winner])
			gui.set_text(win_text, message.winner .. " Wins!")
			AudioManager:play_oneshot("win")
		end
	end
end

function update(self, dt)
	self.druid:update(dt)
end

function final(self)
	self.druid:final()
end
